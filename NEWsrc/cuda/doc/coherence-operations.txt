simulation_data *run_coherence_simulation (parameters*)
	{
	Declaration of variables
	#ifndef CUDA
	Declaration of randomization-related variables
	#endif

	Save current time (for Execution time)

	Determine the number of samples from the user options and adjust how frequently the flushing to the log/results file happens

	Fill in some of the optimizations

	Fill in the cell arrays necessary for conducting the simulation

	Determine which cells are inputs and which are outputs

	If we are performing a vector table simulation we consider only the activated inputs

	Allocate memory to hold the simulation data

	Initialize the simualtion data structure

	Set the number of simulation samples to be the desired number of recorded samples

	Allocate the memory for each trace

	Create and initialize the inputs into the sim data structure

	Create and initialize the outputs into the sim data structure

	Create and initialize the clock data

	Refresh all the kink energies and neighbours-- //

	#ifndef CUDA
	Randomize the design to reduce numerical error
	#endif

	Do something related to choosing exhaustive or vector table  

	Converge the steady state coherence vector for each cell so that the simulation starts without any transients

------------ Critical part begins here ------------ 
  #ifndef CUDA 
	Perform the iteration over all samples 
	{
		Every 10000 samples
		{
		   Update the progress bar
			#ifdef DESIGNER
			Redraw the design if the user wants it to appear animated
			{
				GTK Code
			}
			#endif
		}

		Do something (WHAT??) related to exhaustive or vector table  
		--- MAYBE: if exh. calculate polarization of every cell in layout, if vect.tbl. compute only part of it
		---		  this can possibly be an initialization phase for every sample

		Every 10000 samples
		{
			Iterate over all cells in design using design_bus_layout_iter_first (to init iteration) and design_bus_layout_iter_next (to forward the iteration)
			Compute polarization value for cells and save this value to output structure
		}

		Randomize cells so as to minimize numerical error
		
		Run the iteration with the given clock value
		---run_coherence_iteration (parameters):
		---   Loop through all the cells in the design
		---      Don't simulate the input and fixed cells
      ---      Clock_value = calculate_clock_value
      ---		Calculate the sum of neighboring polarizations
		---		Reassign Lambda Values
  
		for (number of layers)
			for (number_of_cells_in_layer)
		   {
		   	Don't simulate the input and the fixed cells (?)
					On error return sim_data...
				   ...else Set the new polariztion (function implemented in QCADCell.c)
		   }

		If this sample has to be recorded...(Every 10000 samples)
		{
			do sth (WHAT??)
		   ( Collect all the output data from the simulation )
		}

		/*STOP SIMULATION IS SET VIA GUI! (this is why it is a designer-realted variable)*/
		if (TRUE == STOP_SIMULATION) return sim_data;
	}
------------ Critical part ends here ------------ 

========================================================================================
=																													=
=												DISCUSSION														=
=																													=
========================================================================================
=	1. What is crispy clear:
=		a.	this loop is done num_samples times - each of these samples represents 
=			one discrete state of the whole system. Clear correspondance w/ cuda threads
=		b.	randomization is used to reduce numerical error associated to efficient (?)
=			implementation of the algorithm (no state s and s+1 in memory)
=		c.	input and fixed cells are not to be evolved
=	2. What is partly understood
=		a. polarization update: how is it carried on? Look at qcad_cell_set_polarization
=			in QCADCell.c; it is more than simply switching z values
=	3. What is not understood
=		a.	how do we treat exhaustive vs. vector table (ONLY EX.? HOW?)
=     b. somehow after x samples (10000?) something is written back into the output
=			structure - there is where we'll look for correctness. THIS STRUCTURE MUST
=			BE WELL UNDERSTOOD BEFORE GOING ON CODING (imho)
========================================================================================








































  #else
  //CUDA code for coherence simulation goes here
  //tentative pseudo algorithm
  //1st: get a suitable representation of the design which can be copied easily
  //     into global memory
  //     HINT:
  //	 typedef struct cuda_cell_t{
  //			 	long int id;	   //unique id
  //				(void*) data_cell; //replace void* either w/ pointer to
  //								   //suitable struct or w/ data itself
  //				int* neighbors;	   //long int vector <-> id of cell /0
  //     } cuda_cell  
  //2nd: have the representation take into account neighborhood as a list of 
  //     pointers to the ids of the neghbours
  //3rd: copy everything into global memory
  //4th: kernel copies into its local memory _A COPY OF THE DATA OF ITS NEIGH._
  //5th: kernel can process the evolution from s to s+1 using local data and 
  //     updates the state of the cell it is working on
  //6th: repeat 4-5 until total number of samples are computed
  //7th: copy everything from device memory to host memory, mapping correctly
   
   // Generate CUDA-Compatible structures
   float *polarization, *clock, *lambda_x, *lambda_y, *lambda_z, *Ek;
   int *neighbours
   int cells_number;
   int max_neighbours_number;
   CUDA_coherence_OP *CUDA_options;
   CUDA_coherence_optimizations *CUDA_optimization;
   int index;

   // Compute the number of cells, the max neighbours count and set the cuda_id field of each cell
   cells_number = 0;
   max_neighbours_number = 0;
   index = 0;
   for (i = 0; i < number_of_cell_layers; i++)
   {
      for (j = 0; j < number_of_cells_in_layer[i]; j++)
      {
	 if (((coherence_model *)sorted_cells[i][j]->cell_model)->number_of_neighbours > max_neighbours_number)
	    max_neighbours_number = ((coherence_model *)sorted_cells[i][j]->cell_model)->number_of_neighbours;
   
         sorted_cells[i][j]->cuda_id = index;

         index++;
      }
      cells_number += number_of_cells_in_layer[i];
   }

   // Allocate CUDA-Compatible structures
   polarization =               (float*) malloc (sizeof(float)*cells_number);
   clock =                      (float*) malloc (sizeof(float)*cells_number);
   lambda_x =                   (float*) malloc (sizeof(float)*cells_number);
   lambda_y =                   (float*) malloc (sizeof(float)*cells_number);
   lambda_z =                   (float*) malloc (sizeof(float)*cells_number);
   Ek =	                        (float*) malloc (sizeof(float)*cells_number*max_neighbours_number);
   neighbours =                 (int*) malloc (sizeof(int)*cells_number*max_neighbours_number);
   CUDA_options =               (CUDA_coherence_OP*) malloc (sizeof(CUDA_coherence_OP));
   CUDA_optimizations_options = (CUDA_coherence_optimizations*) malloc (sizeof(CUDA_coherence_optimizations));

   // Fill CUDA-Compatible structures
   index = 0;
   for (i = 0; i < number_of_cell_layers; i++)
   {
      for (j = 0; j < number_of_cells_in_layer[i]; j++)
      {
         polarization[index] = qcad_cell_calculate_polarization(*sorted_cells[i][j]);
         //clock[index] = ???;
         lambda_x[index] = (sorted_cells[i][j]->cell_model)->lambda_x;
         lambda_y[index] = (sorted_cells[i][j]->cell_model)->lambda_y;
         lambda_z[index] = (sorted_cells[i][j]->cell_model)->lambda_z;
         for (k = 0; k < max_neighbours_number; k++)
         {
            if (k < (sorted_cells[i][j]->cell_model)->number_of_neighbours)
            {
               Ek[index*max_neighbours_number+k] = (sorted_cells[i][j]->cell_model)->Ek[k];
               neighbours[index*max_neighbours_number+k] = ((sorted_cells[i][j]->cell_model)->neighbours[k])->cuda_id;
            }
            else
            {
               Ek[index*max_neighbours_number+k] = -1;
               neighbours[index*max_neighbours_number+k] = -1;
            }
         }
         index++;
      }
   }

   CUDA_options->T                      = options->T;
   CUDA_options->relaxation             = options->relaxation;
   CUDA_options->time_step              = options->time_step;
   CUDA_options->duration               = options->duration;
   CUDA_options->clock_high             = options->clock_high;
   CUDA_options->clock_low              = options->clock_low;
   CUDA_options->clock_shift            = options->clock_shift;
   CUDA_options->clock_amplitude_factor = options->clock_amplitude_factor;
   CUDA_options->radius_of_effect       = options->radius_of_effect;
   CUDA_options->epsilonR               = options->epsilonR;
   CUDA_options->layer_separation       = options->layer_separation;
   CUDA_options->algorithm              = options->algorithm;


   CUDA_optimization_options->clock_prefactor             = optimization_options.clock_prefactor;
   CUDA_optimization_options->clock_shift                 = optimization_options.clock_shift;
   CUDA_optimization_options->four_pi_over_number_samples = optimization_options.four_pi_over_number_samples;
   CUDA_optimization_options->two_pi_over_number_samples  = optimization_options.two_pi_over_number_samples;
   CUDA_optimization_options->hbar_over_kBT               = optimization_options.hbar_over_kBT;

   // Launch GPU Simulation
   launch_coherence_vector_simulation (polarization, clock, lambda_x, lambda_y, lambda_z, Ek, neighbours, cells_number, 
                                       max_neighbours_number, number_samples,CUDA_options, CUDA_optimization_options);
 
  #endif

  // Free the neigbours and Ek array introduced by this simulation//
  for (k = 0; k < number_of_cell_layers; k++)
    for (l = 0; l < number_of_cells_in_layer[k]; l++)
      {
      g_free (((coherence_model *)sorted_cells[k][l]->cell_model)->neighbours);
      g_free (((coherence_model *)sorted_cells[k][l]->cell_model)->neighbour_layer);
      g_free (((coherence_model *)sorted_cells[k][l]->cell_model)->Ek);
      }

  simulation_inproc_data_free (&number_of_cell_layers, &number_of_cells_in_layer, &sorted_cells) ;

  // Restore the input flag for the inactive inputs
  if (VECTOR_TABLE == SIMULATION_TYPE)
    for (i = 0 ; i < pvt->inputs->icUsed ; i++)
      exp_array_index_1d (pvt->inputs, BUS_LAYOUT_CELL, i).cell->cell_function = QCAD_CELL_INPUT ;

  // -- get and print the total simulation time -- //
  if ((end_time = time (NULL)) < 0)
    fprintf (stderr, "Could not get end time\n");

/*  command_history_message ("Total simulation time: %g s\n", (double)(end_time - start_time));*/
/*  set_progress_bar_visible (FALSE) ;*/
  return sim_data;
  }//run_coherence

