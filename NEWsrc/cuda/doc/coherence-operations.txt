simulation_data *run_coherence_simulation (parameters*)
	{
	Declaration of variables
	#ifndef CUDA
	Declaration of randomization-related variables
	#endif

	Save current time (for Execution time)

	Determine the number of samples from the user options and adjust how frequently the flushing to the log/results file happens

	Fill in some of the optimizations

	Fill in the cell arrays necessary for conducting the simulation

	Determine which cells are inputs and which are outputs

	If we are performing a vector table simulation we consider only the activated inputs

	Allocate memory to hold the simulation data

	Initialize the simualtion data structure

	Set the number of simulation samples to be the desired number of recorded samples

	Allocate the memory for each trace

	Create and initialize the inputs into the sim data structure

	Create and initialize the outputs into the sim data structure

	Create and initialize the clock data

	Refresh all the kink energies and neighbours-- //

	#ifndef CUDA
	Randomize the design to reduce numerical error
	#endif

	Do something related to choosing exhaustive or vector table  

	Converge the steady state coherence vector for each cell so that the simulation starts without any transients

------------ Critical part ------------ 
  #ifndef CUDA 
	Perform the iterations over all samples 
	for (j = 0; j < number_samples; j++)
	{
		if (0 == j % 10000)
      {
      Update the progress bar
		#ifdef DESIGNER
		Redraw the design if the user wants it to appear animated
		{
			GTK Code
		}
		#endif
     	}


	Do something (WHAT??) related to choosing exhaustive or vector table  

	If this sample has to be recorded...
	{
		do sth (WHAT??)
	}

	Randomize cells so as to minimize numerical error
   
   Run the iteration with the given clock value
	---run_coherence_iteration (parameters);

   Set the cell polarizations to the lambda_z value - this is basically where the system evolves
    for (number of layers)
      for (number_of_cells_in_layer)
        {
        Don't simulate the input and the fixed cells
        if (((QCAD_CELL_INPUT == sorted_cells[k][l]->cell_function) ||
             (QCAD_CELL_FIXED == sorted_cells[k][l]->cell_function)))
          continue;
        if (fabs (((coherence_model *)sorted_cells[k][l]->cell_model)->lambda_z) > 1.0)
          {
				/*          command_history_message ("I had to abort the simulation at iteration %d because the polarization = %e was diverging.\nPossible cause is the time step is too large.\n
								Alternatively, you can decrease the relaxation time to reduce oscillations.\n",j, ((coherence_model *)sorted_cells[k][l]->cell_model)->lambda_z);*/
				/*          command_history_message ("time step was set to %e\n", options->time_step);*/
          return sim_data;
          }
        qcad_cell_set_polarization (sorted_cells[k][l], ((coherence_model *)sorted_cells[k][l]->cell_model)->lambda_z);
        }

    // -- collect all the output data from the simulation -- //
    if (0 == j % record_interval)
      for (design_bus_layout_iter_first (design->bus_layout, &bli, QCAD_CELL_OUTPUT, &i) ; i > -1 ; design_bus_layout_iter_next (&bli, &i))
        sim_data->trace[total_number_of_inputs + i].data[j/record_interval] =
          qcad_cell_calculate_polarization (exp_array_index_1d (design->bus_layout->outputs, BUS_LAYOUT_CELL, i).cell) ;

	if (TRUE == STOP_SIMULATION) return sim_data;
  }//for number of samples
  
  
  #else
  //CUDA code for coherence simulation goes here
  //tentative pseudo algorithm
  //1st: get a suitable representation of the design which can be copied easily
  //     into global memory
  //     HINT:
  //	 typedef struct cuda_cell_t{
  //			 	long int id;	   //unique id
  //				(void*) data_cell; //replace void* either w/ pointer to
  //								   //suitable struct or w/ data itself
  //				int* neighbors;	   //long int vector <-> id of cell /0
  //     } cuda_cell  
  //2nd: have the representation take into account neighborhood as a list of 
  //     pointers to the ids of the neghbours
  //3rd: copy everything into global memory
  //4th: kernel copies into its local memory _A COPY OF THE DATA OF ITS NEIGH._
  //5th: kernel can process the evolution from s to s+1 using local data and 
  //     updates the state of the cell it is working on
  //6th: repeat 4-5 until total number of samples are computed
  //7th: copy everything from device memory to host memory, mapping correctly
   
   // Generate CUDA-Compatible structures
   float *polarization, *clock, *lambda_x, *lambda_y, *lambda_z, *Ek;
   int *neighbours
   int cells_number;
   int max_neighbours_number;
   CUDA_coherence_OP *CUDA_options;
   CUDA_coherence_optimizations *CUDA_optimization;
   int index;

   // Compute the number of cells, the max neighbours count and set the cuda_id field of each cell
   cells_number = 0;
   max_neighbours_number = 0;
   index = 0;
   for (i = 0; i < number_of_cell_layers; i++)
   {
      for (j = 0; j < number_of_cells_in_layer[i]; j++)
      {
	 if (((coherence_model *)sorted_cells[i][j]->cell_model)->number_of_neighbours > max_neighbours_number)
	    max_neighbours_number = ((coherence_model *)sorted_cells[i][j]->cell_model)->number_of_neighbours;
   
         sorted_cells[i][j]->cuda_id = index;

         index++;
      }
      cells_number += number_of_cells_in_layer[i];
   }

   // Allocate CUDA-Compatible structures
   polarization =               (float*) malloc (sizeof(float)*cells_number);
   clock =                      (float*) malloc (sizeof(float)*cells_number);
   lambda_x =                   (float*) malloc (sizeof(float)*cells_number);
   lambda_y =                   (float*) malloc (sizeof(float)*cells_number);
   lambda_z =                   (float*) malloc (sizeof(float)*cells_number);
   Ek =	                        (float*) malloc (sizeof(float)*cells_number*max_neighbours_number);
   neighbours =                 (int*) malloc (sizeof(int)*cells_number*max_neighbours_number);
   CUDA_options =               (CUDA_coherence_OP*) malloc (sizeof(CUDA_coherence_OP));
   CUDA_optimizations_options = (CUDA_coherence_optimizations*) malloc (sizeof(CUDA_coherence_optimizations));

   // Fill CUDA-Compatible structures
   index = 0;
   for (i = 0; i < number_of_cell_layers; i++)
   {
      for (j = 0; j < number_of_cells_in_layer[i]; j++)
      {
         polarization[index] = qcad_cell_calculate_polarization(*sorted_cells[i][j]);
         //clock[index] = ???;
         lambda_x[index] = (sorted_cells[i][j]->cell_model)->lambda_x;
         lambda_y[index] = (sorted_cells[i][j]->cell_model)->lambda_y;
         lambda_z[index] = (sorted_cells[i][j]->cell_model)->lambda_z;
         for (k = 0; k < max_neighbours_number; k++)
         {
            if (k < (sorted_cells[i][j]->cell_model)->number_of_neighbours)
            {
               Ek[index*max_neighbours_number+k] = (sorted_cells[i][j]->cell_model)->Ek[k];
               neighbours[index*max_neighbours_number+k] = ((sorted_cells[i][j]->cell_model)->neighbours[k])->cuda_id;
            }
            else
            {
               Ek[index*max_neighbours_number+k] = -1;
               neighbours[index*max_neighbours_number+k] = -1;
            }
         }
         index++;
      }
   }

   CUDA_options->T                      = options->T;
   CUDA_options->relaxation             = options->relaxation;
   CUDA_options->time_step              = options->time_step;
   CUDA_options->duration               = options->duration;
   CUDA_options->clock_high             = options->clock_high;
   CUDA_options->clock_low              = options->clock_low;
   CUDA_options->clock_shift            = options->clock_shift;
   CUDA_options->clock_amplitude_factor = options->clock_amplitude_factor;
   CUDA_options->radius_of_effect       = options->radius_of_effect;
   CUDA_options->epsilonR               = options->epsilonR;
   CUDA_options->layer_separation       = options->layer_separation;
   CUDA_options->algorithm              = options->algorithm;


   CUDA_optimization_options->clock_prefactor             = optimization_options.clock_prefactor;
   CUDA_optimization_options->clock_shift                 = optimization_options.clock_shift;
   CUDA_optimization_options->four_pi_over_number_samples = optimization_options.four_pi_over_number_samples;
   CUDA_optimization_options->two_pi_over_number_samples  = optimization_options.two_pi_over_number_samples;
   CUDA_optimization_options->hbar_over_kBT               = optimization_options.hbar_over_kBT;

   // Launch GPU Simulation
   launch_coherence_vector_simulation (polarization, clock, lambda_x, lambda_y, lambda_z, Ek, neighbours, cells_number, 
                                       max_neighbours_number, number_samples,CUDA_options, CUDA_optimization_options);
 
  #endif

  // Free the neigbours and Ek array introduced by this simulation//
  for (k = 0; k < number_of_cell_layers; k++)
    for (l = 0; l < number_of_cells_in_layer[k]; l++)
      {
      g_free (((coherence_model *)sorted_cells[k][l]->cell_model)->neighbours);
      g_free (((coherence_model *)sorted_cells[k][l]->cell_model)->neighbour_layer);
      g_free (((coherence_model *)sorted_cells[k][l]->cell_model)->Ek);
      }

  simulation_inproc_data_free (&number_of_cell_layers, &number_of_cells_in_layer, &sorted_cells) ;

  // Restore the input flag for the inactive inputs
  if (VECTOR_TABLE == SIMULATION_TYPE)
    for (i = 0 ; i < pvt->inputs->icUsed ; i++)
      exp_array_index_1d (pvt->inputs, BUS_LAYOUT_CELL, i).cell->cell_function = QCAD_CELL_INPUT ;

  // -- get and print the total simulation time -- //
  if ((end_time = time (NULL)) < 0)
    fprintf (stderr, "Could not get end time\n");

/*  command_history_message ("Total simulation time: %g s\n", (double)(end_time - start_time));*/
/*  set_progress_bar_visible (FALSE) ;*/
  return sim_data;
  }//run_coherence

